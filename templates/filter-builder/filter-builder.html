<link rel="stylesheet" href="filter-builder.css">

<template id='filter-builder'>
    <h3 id='currentFilter'></h3>

    <div class='panel'>
        <h4>Allowed Detectors</h4>
        <label for="allowDANTE">DANTE</label>
        <input value="DA" class="allowedDetCheck" id="allowDANTE" type="checkbox"></input>
        <label for="allowDESCANT">DESCANT</label>
        <input value="DS" class="allowedDetCheck" id="allowDESCANT" type="checkbox"></input>
        <label for="allowGRIFFIN">GRIFFIN</label>
        <input value="GR" class="allowedDetCheck" id="allowGRIFFIN" type="checkbox"></input>
        <label for="allowPACES">PACES</label>
        <input value="PA" class="allowedDetCheck" id="allowPACES" type="checkbox"></input>
        <label for="allowSCEPTAR">SCEPTAR</label>
        <input value="SE" class="allowedDetCheck" id="allowSCEPTAR" type="checkbox"></input>
        <label for="allowZDS">ZDS</label>
        <input value="ZD" class="allowedDetCheck" id="allowZDS" type="checkbox"></input>
    </div>

    <div>
        <h4>Filter Logic</h4>
        <div id='logic-wrap'></div>
        <button class='btn btn-info' onclick='addNewOR();'>OR new condition</button>
    </div>

    <div class='panel'>
        <div>
            <label for='filterName'>Filter Name:</label>
            <input type='text' id='filterName' class='wideText'></input>
            <button class='btn btn-info' onclick='writeNewFilter()'>Save Filter Definition</button>
            <button class='btn btn-success'>Save & Apply Filter Definition</button>
        </div>

        <div>
            <label for='filterMenu'>Load / Delete Filter:</label>
            <select id='filterMenu'></select>
            <button class='btn btn-warning'>Load</button>
            <button class='btn btn-danger'>Delete</button>
        </div>
    </div>
</template>

<script>

    function setupFilter(){
        // start initial setup

        // get the ODB filters dir:
        fetchScript('http://' + dataStore.host + '/?cmd=jcopy&odb=/Filter&encoding=json-p-nokeys&callback=processFilter');

    }

    function processFilter(payload){
        // finish initial setup after active filter has arrived

        dataStore.filter = {};              // place to park filter info on the dataStore
        dataStore.filter.table = payload;
        dataStore.filter.orIndex = 0;       // monotonically increasing counter to create unique IDs for new OR blocks
        dataStore.filter.nRows = [];        // array of monotonic counters for number of rows inserted into OR block; OR block # == array index. 

        // populate the current filter
        loadFilter();
        buildFilterMenu();
    }

    function addNewOR(){
        // add a new OR block to the current filter

        var wrap = document.createElement('div');
        wrap.setAttribute('class', 'or-block');
        wrap.setAttribute('id', 'filterCondition' + dataStore.filter.orIndex);
        wrap.innerHTML = Mustache.to_html(
            dataStore.templates['orBlock'], 
            {  
                "orNumber": dataStore.filter.orIndex
            }
        );
        document.getElementById('logic-wrap').appendChild(wrap);

        dataStore.filter.nRows[dataStore.filter.orIndex] = 0;
        dataStore.filter.orIndex++;
    }

    function deleteOR(orNumber){
        // delete the indexed OR block

        deleteNode('filterCondition' + orNumber);
    }

    function addNewAND(orIndex){
        // add a new AND row to the indexed OR block

        var table = document.getElementById('filterContent'+orIndex),
            row = document.createElement('div');
        row.setAttribute('class', 'col-md-12 and-row');
        row.setAttribute('id', 'ANDrow' + orIndex + dataStore.filter.nRows[orIndex])
        row.innerHTML = Mustache.to_html(
            dataStore.templates['andRow'], 
            {  
                "orNumber": orIndex,
                "andNumber": dataStore.filter.nRows[orIndex]
            }
        );
        table.appendChild(row);

        dataStore.filter.nRows[orIndex]++;
    }

    function deleteAND(orNumber, andNumber){
        // delete the indexed AND row in the indexed OR block

        deleteNode('ANDrow' + orNumber + andNumber);
    }

    function changeCounting(orNumber, andNumber){
        // update the UI to reflect whether the indexed row is for singles, coincidences or prescale

        var counting = selected('filterType' + orNumber + andNumber);

        document.getElementById('subconfig'+counting+'0' + orNumber + andNumber).classList.remove('hidden');
        document.getElementById('subconfig'+counting+'1' + orNumber + andNumber).classList.remove('hidden');

        if(counting == 'S'){
            document.getElementById('subconfigC0' + orNumber + andNumber).classList.add('hidden');
            document.getElementById('subconfigC1' + orNumber + andNumber).classList.add('hidden'); 
            document.getElementById('subconfigP0' + orNumber + andNumber).classList.add('hidden');
            document.getElementById('subconfigP1' + orNumber + andNumber).classList.add('hidden');            
        } else if(counting == 'C'){
            document.getElementById('subconfigS0' + orNumber + andNumber).classList.add('hidden');
            document.getElementById('subconfigS1' + orNumber + andNumber).classList.add('hidden'); 
            document.getElementById('subconfigP0' + orNumber + andNumber).classList.add('hidden');
            document.getElementById('subconfigP1' + orNumber + andNumber).classList.add('hidden');            
        } else if(counting == 'P'){
            document.getElementById('subconfigC0' + orNumber + andNumber).classList.add('hidden');
            document.getElementById('subconfigC1' + orNumber + andNumber).classList.add('hidden'); 
            document.getElementById('subconfigS0' + orNumber + andNumber).classList.add('hidden');
            document.getElementById('subconfigS1' + orNumber + andNumber).classList.add('hidden');            
        }
    }

    function loadFilter(){
        // populate the UI with whatever filter definition is currently active according to dataStore.filter.table (== last fetch of /Filter from ODB)

        var currentFilterName = dataStore.filter.table.Current,
            i=0, j,
            conditions;

        setTitle();

        while(dataStore.filter.table.Filters[dataStore.filter.table.Current]['orCondition'+i]){
            addNewOR()
            
            conditions = dataStore.filter.table.Filters[dataStore.filter.table.Current]['orCondition'+i];
            if(Array.isArray(conditions)){
                for(j=0; j<conditions.length; j++)
                    loadAndRow(i, conditions[j])
            }
            else
                loadAndRow(i, conditions)

            i++;

        }
    }

    function buildFilterMenu(){
        // populate the filter dropdown menu with whatever we found in the odb

        var i, option,
            keys = Object.keys(dataStore.filter.table.Filters),
            select = document.getElementById('filterMenu');

        for(i=0; i<keys.length; i++){
            option = document.createElement('option');
            option.innerHTML = keys[i];
            select.appendChild(option);
        }
    }

    function loadAndRow(orIndex, condition){
        // parse the string <condition> and add it as an and row to the indexed or block

        var detector, counting, multiplicity, windowSize, prescale,
            tokens = condition.split('-'),
            detectorPicker, countingPicker, multiIn, windowIn, prescaleIn;

        detector = tokens[0];
        counting = tokens[1];
        if(counting == 'C'){
            multiplicity = parseInt(tokens[2],10);
            windowSize = parseInt(tokens[3],10);
        } else if(counting == 'P'){
            prescale = parseInt(tokens[2],10);
        }

        addNewAND(orIndex);

        detectorPicker = document.getElementById('detectorSelect' + orIndex + (dataStore.filter.nRows[orIndex] - 1) );
        countingPicker = document.getElementById('filterType' + orIndex + (dataStore.filter.nRows[orIndex] - 1) );
        multiIn = document.getElementById('coincConfigInput0' + orIndex + (dataStore.filter.nRows[orIndex] - 1) );
        windowIn = document.getElementById('coincConfigInput1' + orIndex + (dataStore.filter.nRows[orIndex] - 1) );
        prescaleIn = document.getElementById('prescaleConfigInput0' + orIndex + (dataStore.filter.nRows[orIndex] - 1) );

        detectorPicker.value = detector;
        countingPicker.value = counting;
        countingPicker.onchange();

        if(counting == 'C'){
            multiIn.value = multiplicity;
            windowIn.value = windowSize;
        } else if(counting == 'P'){
            prescaleIn.value = prescale;
        }

    }

    function setTitle(){
        // update the title of the current filter from what's been pulled from the odb

        document.getElementById('currentFilter').innerHTML = dataStore.filter.table.Current;
        document.getElementById('filterName').value = dataStore.filter.table.Current;
    }

    function writeNewFilter(){
        // write new filter to the odb
        // note that since we can only write one thing at a time, and must create the variables in a separate operation first,
        // the synchronous order of operations here is important...

        var filterName = 'dummy',//document.getElementById('filterName').value,
            orBlocks = document.getElementById('logic-wrap').getElementsByClassName('or-block'),
            createDeletionRequest, i, andRows, 
            filterEncoding,
            detectorType, countingType, multiplicity, windowSize, prescale,
            multiIn, prescaleIn, windowIn;

        orBlocks = [orBlocks[0], orBlocks[1]]

        // create request URLs
        // first delete this if it exists
        createDeletionRequest = 'http://' + dataStore.host + '?cmd=jdelete&odb=/Filter/Filters/' + filterName + '&encoding=json&callback=createODBstructure';
        // then recreate the array....
        dataStore.filter.createFilterRequest = 'http://' + dataStore.host + '?cmd=jcreate&';
        for(i=0; i<orBlocks.length; i++){
            dataStore.filter.createFilterRequest += 'odb' + (2*i) + '=/Filter/Filters/' + filterName + '/orCondition' + i + '&type' + (2*i) + '=12&strlen' + (2*i) + '=32&arraylen'+ (2*i) +'='+orBlocks[i].getElementsByClassName('and-row').length+'&';
            dataStore.filter.createFilterRequest += 'odb' + (2*i + 1) + '=/Filter/Filters/' + filterName + '/coincWindow' + i + '&type' + (2*i + 1) + '=7&';
        }
        dataStore.filter.createFilterRequest += 'odb' + (2*i) + '=/Filter/Filters/' + filterName + '/EnabledDetTypes&type' + (2*i)  + '=12';
        dataStore.filter.createFilterRequest += '&encoding=json&callback=populateFilter'
        // then set the values in the array
        dataStore.filter.setFilterStepRequests = [];
        for(i=0; i<orBlocks.length; i++){
            andRows = orBlocks[i].getElementsByClassName('and-row');

            // filter encodings and coincidence windows
            filterEncoding = '';
            for(j=0; j<andRows.length; j++){
                multiIn = document.getElementById('coincConfigInput0' + i + j );
                windowIn = document.getElementById('coincConfigInput1' + i + j );
                prescaleIn = document.getElementById('prescaleConfigInput0' + i + j );

                detectorType = selected('detectorSelect' + i + j);
                countingType = selected('filterType' + i + j);
                multiplicity = multiIn.value;
                windowSize = windowIn.value;
                prescale = prescaleIn.value;

                if(j>0)
                    filterEncoding += ',';

                filterEncoding += detectorType + '-' + countingType + '-';
                if(countingType == 'S')
                    filterEncoding += '1';
                else if(countingType == 'C'){
                    filterEncoding += multiplicity + '-';
                    filterEncoding += windowSize
                } else if(countingType == 'P')
                    filterEncoding += prescale
            }

            // different syntax to set one thing versus an array of things...
            if(andRows.length == 1)
                dataStore.filter.setFilterStepRequests.push('http://' + dataStore.host + '?cmd=jset&odb=/Filter/Filters/' + filterName + '/orCondition' + i + '&value=' + filterEncoding);
            else
                dataStore.filter.setFilterStepRequests.push('http://' + dataStore.host + '?cmd=jset&odb=/Filter/Filters/' + filterName + '/orCondition' + i + '[*]&value=' + filterEncoding);
        }

        // sets off a chain of callbacks to delete -> recreate -> populate
        promiseScript(createDeletionRequest)
    }

    function createODBstructure(){
        // callback after deleting old version of the filter being recreated; sends request to recreate filter keys
        promiseScript(dataStore.filter.createFilterRequest);
    }

    function populateFilter(){
        // callback after recreating filter keys; sends request to populate keys
        Promise.all(dataStore.filter.setFilterStepRequests.map(promiseScript)).then(
            console.log('filter rewrite complete')
        )      
    }

</script>













